import chess
import chess.pgn
import numpy as np

def fen_to_numeric(char):
    
    # Switches fen characters to numeric piece values
    # White pieces are positive numbers and black pieces are negative numbers
    #
    # argument : A non-numeric character in a FEN string
    # return   : Numeric value of input piece
    
    switcher = {
        'r' : -5,
        'n' : -3,
        'b' : -4,
        'q' : -9,
        'k' : -10,
        'p' : -1,
        'R' : 5,
        'N' : 3,
        'B' : 4,
        'Q' : 9,
        'K' : 10,
        'P' : 1,
    }
    return(switcher.get(char))

def get_board_state(board): 
    
    # Takes a chess board and converts the PGN to FEN notation. Then subs the 
    # FEN characters for the value of each piece and splits the result into an array
    #
    # argument : chess board object
    # return   : input array for NN

    shredder_fen = list((board.shredder_fen().split(" ")[0]).replace("/",""))
    numeric_fen = []
    for char in shredder_fen:
        if(char.isdigit()): # empty squares between pieces: add zeros
            for i in range(int(char)):
                numeric_fen.append(0)
        else: # convert piece notation to numeric value
            numeric_fen.append(fen_to_numeric(char))
    
    # Whose turn is it?
    if(board.turn == True):
        numeric_fen + [1] # White to move
    else:
        numeric_fen + [0] # Black to move
    
    # Is the king in check?
    if(board.is_check() == True):
        numeric_fen += [1] # Yes
    else:
        numeric_fen += [0] # No
    
    # Is queenside castling available for player?
    if(board.has_queenside_castling_rights(board.turn)):
        numeric_fen += [1] # Yes
    else:
        numeric_fen += [0] # No
        
    # Is kingside castling available for player?
    if(board.has_kingside_castling_rights(board.turn)):
        numeric_fen += [1] # Yes
    else:
        numeric_fen += [0] # No
        
    # Is queenside castling available for opponent?
    if(board.has_queenside_castling_rights(not(board.turn))):
        numeric_fen += [1] # Yes
    else:
        numeric_fen += [0] # No
        
    # Is kingside castling available for player?
    if(board.has_kingside_castling_rights(not(board.turn))):
        numeric_fen += [1] # Yes
    else:
        numeric_fen += [0] # No
        
    # How many turns have passed
    numeric_fen += [board.ply()]

    return(numeric_fen)

    # Who won?
#     if(board.has_kingside_castling_rights(not(board.turn))):
#         numeric_fen += [1] # Yes
#     else:
#         numeric_fen += [0] # No

#     return(numeric_fen)
    

def game_to_data(game, color, period):
    
    # Takes a chess game and processes it into a inputs to the NN
    # The board state is a numeric representation generated by get_board_state()
    # target_origin move is the space from which a piece is moved: target for first NN
    # target_dest move is the space to which a piece is moved: target for second NN
    #
    # argument : chess game object
    # return   : [flattened board states, target origin moves, target destination moves]
    
    # determine upper and lower bound to separate early, mid, and late game
    if period == 'early':
        lb = 0
        ub = 14
    elif period == 'mid':
        lb = 15
        ub = 40
    else:
        lb = 41
        ub = np.inf
    
    board_state = []
    target_origin = []
    target_dest = []
    board = game.board()
    
    # Who won?
    if(game.headers['Result'] == "1-0"):
        winner = [1]
    elif(game.headers['Result'] == "0-1"):
        winner = [-1]
    else:
        winner = [0]
    
    for move in game.mainline_moves():
        if(board.turn == color and lb <= board.ply() <= ub):
            board_state.append(get_board_state(board) + winner) # add the board state
            target_origin.append(move.from_square)
            target_dest.append(move.to_square)
        board.push(move) # play the next move on the board
    
    return board_state, target_origin, target_dest

def aggregate_game_data(game1, game2):
    
    # Combines game data 
    #
    # argument : chess game object
    # return   : [flattened board states, target origin moves, target destination moves]
    
    X1 = game1[0]
    X2 = game2[0]
    y1 = game1[1]
    y2 = game2[1]
    z1 = game1[2]
    z2 = game2[2]

    return X1 + X2, y1 + y2, z1 + z2

def gen_nn_data(pgn_games, color, period):
    
    # Wrapper for the other functions. Goes through the list of games and converts the
    # games to training and target data
    #
    # argument : list of chess game objects
    # return   : [flattened board states, target origin moves, target destination moves]

    nn_data = game_to_data(pgn_games[0], color, period)
    pgn_games = pgn_games[1:]
    
    for game in pgn_games:
        nn_data = aggregate_game_data(nn_data, game_to_data(game, color, period))
    
    return np.array(nn_data[0]), np.array(nn_data[1]), np.array(nn_data[2]) # inputs, target1, target2

def read_pgn_from_file(file):
    
    # Reads in all of the games in PGN form from a .pgn file and saves them as a list
    #
    # argument : .pgn file path
    # return   : list of chess game objects
    
    pgn = open(file)
    pgn_games = []
    while(True):
        game = chess.pgn.read_game(pgn)
        if(game == None):
            break
        pgn_games.append(game)
    return(pgn_games)

def mod_MaP_inputs(X, y1):

    # Used for the Move-a-Piece NN. Adds the selected piece (y1 target) as an input to the second NN
    #
    # argument : SaP input array
    # return   : MaP input Array (72 elements per row)
    
    MaP_input = []
    for i in range(len(X)):
        MaP_input.append(np.append(X[i], y1[i]))
    return np.array(MaP_input)